//
//  pplrw.m
//  kfund
//
//  Created by Seo Hyun-gyu on 1/3/24.
//

#import "pplrw.h"
#import <Foundation/Foundation.h>
#import "krw.h"
#import "pte.h"
#import "offsets.h"

#define P_PAGE_SIZE 0x4000
#define P_PAGE_MASK 0x3FFF

#define PERM_KRW_URW 0x7 // R/W for kernel and user
#define FAKE_PHYSPAGE_TO_MAP 0x13370000
#define L2_BLOCK_PAGECOUNT (L2_BLOCK_SIZE / PAGE_SIZE)
#define PPLRW_USER_MAPPING_OFFSET   0x7000000000
#define PPLRW_USER_MAPPING_TTEP_IDX (PPLRW_USER_MAPPING_OFFSET / 0x1000000000)

#define min(a,b) (((a)<(b))?(a):(b))

void *phystouaddr(uint64_t pa)
{
    uint64_t gPhysBase = get_gphysbase();
    uint64_t gPhysSize = get_gphysize();
    
    errno = 0;
    bool doBoundaryCheck = (gPhysBase != 0 && gPhysSize != 0);
    if (doBoundaryCheck) {
        if (pa < gPhysBase || pa >= (gPhysBase + gPhysSize)) {
            errno = 1030;
            return 0;
        }
    }

    return (void *)(pa + PPLRW_USER_MAPPING_OFFSET);
}

int physreadbuf_pplrw(uint64_t pa, void* output, size_t size)
{
//    if(gPPLRWStatus == kPPLRWStatusNotInitialized) {
//        bzero(output, size);
//        return -1;
//    }

    void *uaddr = phystouaddr(pa);
    if (!uaddr && errno != 0) {
        memset(output, 0x0, size);
        return errno;
    }

    asm volatile("dmb sy");
    memcpy(output, uaddr, size);
    return 0;
}


uint64_t physread64_pplrw(uint64_t pa)
{
    uint64_t v;
    physreadbuf_pplrw(pa, &v, sizeof(v));
    return v;
}


uint64_t vtophys_pplrw(uint64_t ttep, uint64_t va)
{
    errno = 0;
    
    uint64_t table1Entry = physread64_pplrw((va >> 0x21) & 0x38 + ttep);
    if((table1Entry & 1) == 0) {
        errno = 1042;
        return 0;
    }
    if((table1Entry & 2) != 0) {
        uint64_t table2Entry = physread64_pplrw((va >> 0x16) & 0x3ff8 + (table1Entry & 0xFFFFF000));
        if((table2Entry & 1) != 0) {
            if((table2Entry & 2) == 0) {
                return (((0x1FFFFFF & 0xFFFFFC000) ^ 0xFFFFFFFFC000) & table2Entry) | (0x1FFFFFF & va);
            }
            uint64_t table3Entry = physread64_pplrw((va >> 0xb) & 0x3ff8 + (table2Entry & 0xFFFFF000));
            if((~table3Entry & 3) == 0) {
                if((table3Entry & 2) == 0)
                    return 0;
                return (((0x3fff & 0xFFFFFC000) ^ 0xFFFFFFFFC000) & table3Entry) | (0x3fff & va);
            }
        }
        errno = 1042;
        return 0;
    }
    return (((0xFFFFFFFFF & 0xFFFFFC000) ^ 0xFFFFFFFFC000) & table1Entry) | (0xFFFFFFFFF & va);
        
    
//    const uint64_t ROOT_LEVEL = PMAP_TT_L1_LEVEL;
//    const uint64_t LEAF_LEVEL = PMAP_TT_L3_LEVEL;

//    uint64_t pa = 0;

//    for (uint64_t cur_level = ROOT_LEVEL; cur_level <= LEAF_LEVEL; cur_level++) {
//        uint64_t offmask, shift, index_mask, valid_mask, type_mask, type_block;
//        switch (cur_level) {
//            case PMAP_TT_L0_LEVEL: {
//                offmask = ARM_16K_TT_L0_OFFMASK;
//                shift = ARM_16K_TT_L0_SHIFT;
//                index_mask = ARM_16K_TT_L0_INDEX_MASK;
//                valid_mask = ARM_TTE_VALID;
//                type_mask = ARM_TTE_TYPE_MASK;
//                type_block = ARM_TTE_TYPE_BLOCK;
//                break;
//            }
//            case PMAP_TT_L1_LEVEL: {
//                offmask = ARM_16K_TT_L1_OFFMASK;
//                shift = ARM_16K_TT_L1_SHIFT;
//                index_mask = ARM_16K_TT_L1_INDEX_MASK;
//                valid_mask = ARM_TTE_VALID;
//                type_mask = ARM_TTE_TYPE_MASK;
//                type_block = ARM_TTE_TYPE_BLOCK;
//                break;
//            }
//            case PMAP_TT_L2_LEVEL: {
//                offmask = ARM_16K_TT_L2_OFFMASK;
//                shift = ARM_16K_TT_L2_SHIFT;
//                index_mask = ARM_16K_TT_L2_INDEX_MASK;
//                valid_mask = ARM_TTE_VALID;
//                type_mask = ARM_TTE_TYPE_MASK;
//                type_block = ARM_TTE_TYPE_BLOCK;
//                break;
//            }
//            case PMAP_TT_L3_LEVEL: {
//                offmask = ARM_16K_TT_L3_OFFMASK;
//                shift = ARM_16K_TT_L3_SHIFT;
//                index_mask = ARM_16K_TT_L3_INDEX_MASK;
//                valid_mask = ARM_PTE_TYPE_VALID;
//                type_mask = ARM_PTE_TYPE_MASK;
//                type_block = ARM_TTE_TYPE_L3BLOCK;
//                break;
//            }
//            default: {
//                errno = 1041;
//                return 0;
//            }
//        }
//    uint64_t offmask, shift, index_mask, valid_mask, type_mask, type_block;
//    offmask = ARM_16K_TT_L1_OFFMASK;
//    shift = ARM_16K_TT_L1_SHIFT;
//    index_mask = ARM_16K_TT_L1_INDEX_MASK;
//    valid_mask = ARM_TTE_VALID;
//    type_mask = ARM_TTE_TYPE_MASK;
//    type_block = ARM_TTE_TYPE_BLOCK;
//
//        uint64_t tte_index = (va & index_mask) >> shift;
//        uint64_t tte_pa = ttep + (tte_index * sizeof(uint64_t));
//        uint64_t tte = physread64_pplrw(tte_pa);
//
//        if ((tte & valid_mask) != valid_mask) {
//            errno = 1042;
//            return 0;
//        }
//
//        if ((tte & type_mask) == type_block) {
//            pa = ((tte & ARM_TTE_PA_MASK & ~offmask) | (va & offmask));
//            break;
//        }
//
//        ttep = tte & ARM_TTE_TABLE_MASK;
//    }
//
//    return pa;
}



uint64_t kvtophys_pplrw(uint64_t va)
{
    return vtophys_pplrw(get_gcputtep(), va);
}

int physwritebuf_pplrw(uint64_t pa, const void* input, size_t size)
{
//    if(gPPLRWStatus == kPPLRWStatusNotInitialized) {
//        return -1;
//    }

    void *uaddr = phystouaddr(pa);
    if (!uaddr && errno != 0) {
        return errno;
    }

    memcpy(uaddr, input, size);
    asm volatile("dmb sy");
    return 0;
}

int kreadbuf_pplrw(uint64_t kaddr, void* output, size_t size)
{
    bzero(output, size);
//    if(gPPLRWStatus == kPPLRWStatusNotInitialized) {
//        return -1;
//    }

    uint64_t va = kaddr;
    uint8_t *data = output;
    size_t sizeLeft = size;

    while (sizeLeft > 0) {
        uint64_t virtPage = va & ~P_PAGE_MASK;
        uint64_t pageOffset = va & P_PAGE_MASK;
        uint64_t readSize = min(sizeLeft, P_PAGE_SIZE - pageOffset);

        uint64_t physPage = kvtophys_pplrw(virtPage);
        if (physPage == 0 && errno != 0)
        {
            printf("[kreadbuf] Lookup failure when trying to read %zu bytes at 0x%llX, aborting\n", size, kaddr);
            return errno;
        }

        int pr = physreadbuf_pplrw(physPage + pageOffset, &data[size - sizeLeft], readSize);
        if (pr != 0) {
            printf("[kreadbuf] Physical read at %llx failed: %d\n", physPage + pageOffset, pr);
            return pr;
        }

        va += readSize;
        sizeLeft -= readSize;
    }

    return 0;
}

int kwritebuf_pplrw(uint64_t kaddr, const void* input, size_t size)
{
//    if(gPPLRWStatus == kPPLRWStatusNotInitialized) {
//        return -1;
//    }

    uint64_t va = kaddr;
    const uint8_t *data = input;
    size_t sizeLeft = size;

    while (sizeLeft > 0) {
        uint64_t virtPage = va & ~P_PAGE_MASK;
        uint64_t pageOffset = va & P_PAGE_MASK;
        uint64_t writeSize = min(sizeLeft, P_PAGE_SIZE - pageOffset);

        uint64_t physPage = kvtophys_pplrw(virtPage);
        if (physPage == 0 && errno != 0)
        {
            printf("[kwritebuf] Lookup failure when trying to read %zu bytes at 0x%llX, aborting\n", size, kaddr);
            return errno;
        }

        int pr = physwritebuf_pplrw(physPage + pageOffset, &data[size - sizeLeft], writeSize);
        if (pr != 0) {
            printf("[kwritebuf] Physical write at %llx failed: %d\n", physPage + pageOffset, pr);
            return pr;
        }

        va += writeSize;
        sizeLeft -= writeSize;
    }

    return 0;
}

uint32_t kread32_pplrw(uint64_t va)
{
    uint32_t v;
    kreadbuf_pplrw(va, &v, sizeof(v));
    return v;
}
