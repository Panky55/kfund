//
//  escalate.m
//  kfund
//
//  Created by Seo Hyun-gyu on 1/3/24.
//

#import <Foundation/Foundation.h>
#import "escalate.h"
#import "offsets.h"
#import "proc.h"
#import "krw.h"
#import "jailbreak.h"
#import "kcall.h"
#import "../ViewController.h"

bool rootify(pid_t pid) {
    if (!pid) return false;

    uint64_t proc = proc_of_pid(pid);
    uint64_t proc_ro = kread64(proc + off_p_proc_ro);
    uint64_t ucred = kread64(proc_ro + off_p_ro_p_ucred);
    
    kwrite32(proc + off_p_uid, 0);
    kwrite32(proc + off_p_ruid, 0);
    kwrite32(proc + off_p_gid, 0);
    kwrite32(proc + off_p_rgid, 0);
    
    uint64_t cr_posix_p = kvtophys(ucred + off_u_cr_posix);
    physwrite32(cr_posix_p + off_cr_uid, 0);
    physwrite32(cr_posix_p + off_cr_ruid, 0);
    physwrite32(cr_posix_p + off_cr_svuid, 0);
    physwrite32(cr_posix_p + off_cr_ngroups, 1);
    physwrite32(cr_posix_p + off_cr_groups, 0);
    physwrite32(cr_posix_p + off_cr_rgid, 0);
    physwrite32(cr_posix_p + off_cr_svgid, 0);
    
    return (kread32(proc + off_p_uid) == 0) ? true : false;
}

uint64_t unsandbox(pid_t pid) {
    print_log("Unsandboxing pid %d", pid);
    
    uint64_t proc = proc_of_pid(pid);
    uint64_t proc_ro = kread64(proc + off_p_proc_ro);
    uint64_t ucred = kread64(proc_ro + off_p_ro_p_ucred);
    uint64_t cr_label = kread64(ucred + off_u_cr_label);
    uint64_t orig_sb = kread64(cr_label + off_sandbox_slot);
    
    physwrite64(kvtophys(cr_label + off_sandbox_slot), 0);
    
    return (kread64(cr_label + off_sandbox_slot) == 0) ? orig_sb : NO;
}

BOOL sandbox(pid_t pid, uint64_t sb) {
    if (!pid) return NO;
    
    printf("[*] Sandboxing pid %d with slot at 0x%llx", pid, sb);
    
    uint64_t proc = proc_of_pid(pid);
    uint64_t proc_ro = kread64(proc + off_p_proc_ro);
    uint64_t ucred = kread64(proc_ro + off_p_ro_p_ucred);
    uint64_t cr_label = kread64(ucred + off_u_cr_label);
    
    physwrite64(kvtophys(cr_label + off_sandbox_slot), sb);
    
    return (kread64(cr_label + off_sandbox_slot) == sb) ? YES : NO;
}

uint64_t borrow_entitlements(pid_t to_pid, pid_t from_pid) {
    uint64_t to_proc = proc_of_pid(to_pid);
    uint64_t from_proc = proc_of_pid(from_pid);
    
    uint64_t to_proc_ro = kread64(to_proc + off_p_proc_ro);
    uint64_t from_proc_ro = kread64(from_proc + off_p_proc_ro);
    
    uint64_t to_ucred = kread64(to_proc_ro + off_p_ro_p_ucred);
    uint64_t from_ucred = kread64(from_proc_ro + off_p_ro_p_ucred);
    
    uint64_t to_cr_label = kread64(to_ucred + off_u_cr_label);
    uint64_t from_cr_label = kread64(from_ucred + off_u_cr_label);
    
    uint64_t to_amfi = kread64(to_cr_label + off_amfi_slot);
    uint64_t from_amfi = kread64(from_cr_label + off_amfi_slot);
    
    physwrite64(kvtophys(to_cr_label + off_amfi_slot), from_amfi);
    
    return to_amfi;
}

void unborrow_entitlements(pid_t to_pid, uint64_t to_amfi) {
    uint64_t to_proc = proc_of_pid(to_pid);
    uint64_t to_proc_ro = kread64(to_proc + off_p_proc_ro);
    uint64_t to_ucred = kread64(to_proc_ro + off_p_ro_p_ucred);
    uint64_t to_cr_label = kread64(to_ucred + off_u_cr_label);
    
    physwrite64(kvtophys(to_cr_label + off_amfi_slot), to_amfi);
}

uint64_t borrow_ucreds(pid_t to_pid, pid_t from_pid) {
    uint64_t to_proc = proc_of_pid(to_pid);
    uint64_t from_proc = proc_of_pid(from_pid);
    
    uint64_t to_proc_ro = kread64(to_proc + off_p_proc_ro);
    uint64_t from_proc_ro = kread64(from_proc + off_p_proc_ro);
    
    uint64_t to_ucred = kread64(to_proc_ro + off_p_ro_p_ucred);
    uint64_t from_ucred = kread64(from_proc_ro + off_p_ro_p_ucred);
    
    physwrite64(kvtophys(to_proc_ro + off_p_ro_p_ucred), from_ucred);
    
    return to_ucred;
}

void unborrow_ucreds(pid_t to_pid, uint64_t to_ucred) {
    uint64_t to_proc = proc_of_pid(to_pid);
    uint64_t to_proc_ro = kread64(to_proc + off_p_proc_ro);
    
    physwrite64(kvtophys(to_proc_ro + off_p_ro_p_ucred), to_ucred);
}


bool set_task_platform(pid_t pid, bool set) {
    uint64_t proc = proc_of_pid(pid);
    uint64_t task = kread64(proc + off_p_task);
    uint32_t t_flags = kread32(task + off_task_t_flags);
    
    if (set) {
        t_flags |= TF_PLATFORM;
    } else {
        t_flags &= ~(TF_PLATFORM);
    }
    
    kwrite32(task + off_task_t_flags, t_flags);
    
    return true;
}

void set_proc_csflags(pid_t pid) {
    uint64_t proc = proc_of_pid(pid);
    uint64_t proc_ro = kread64(proc + off_p_proc_ro);
    
    uint32_t csflags = kread32(proc_ro + off_p_ro_p_csflags);
    csflags = csflags | CS_DEBUGGED | CS_PLATFORM_BINARY | CS_INSTALLER | CS_GET_TASK_ALLOW;
    csflags &= ~(CS_RESTRICT | CS_HARD | CS_KILL);
    
    physwrite32(kvtophys(proc_ro + off_p_ro_p_csflags), csflags);
}

uint64_t get_cs_blob(pid_t pid) {
    uint64_t proc = proc_of_pid(pid);
    uint64_t textvp = kread64(proc + off_p_textvp);
    uint64_t ubcinfo = kread64(textvp + off_vnode_vu_ubcinfo);
    return kread64(ubcinfo + off_ubc_info_cs_blobs);
}

void set_csb_platform_binary(pid_t pid) {
    uint64_t cs_blob = get_cs_blob(pid);
    physwrite32(kvtophys(cs_blob + off_cs_blob_csb_platform_binary), 1);
}

void platformize(pid_t pid) {
    set_task_platform(pid, true);
    set_proc_csflags(pid);
    set_csb_platform_binary(pid);
}
