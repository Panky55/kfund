//
//  bootstrap.m
//  kfund
//
//  Created by Seo Hyun-gyu on 1/5/24.
//

#import <Foundation/Foundation.h>
#import <sys/stat.h>
#import "bootstrap.h"
#import "utils.h"
#import "kcall.h"

int remountPrebootPartition(bool writable) {
    int ret = 0;
    if(writable) {
        ret = util_runCommand("/sbin/mount", "-u", "-w", "/private/preboot", NULL, NULL, NULL, NULL);
    } else {
        ret = util_runCommand("/sbin/mount", "-u", "/private/preboot", NULL, NULL, NULL, NULL, NULL);
    }
    return ret;
}

int UUIDPathPermissionFixup(void) {
    NSString *UUIDPath = [NSString stringWithFormat:@"%s%s", "/private/preboot/", getBootManifestHash()];
    
    struct stat UUIDPathStat;
    if (stat(UUIDPath.UTF8String, &UUIDPathStat) != 0) {
        printf("Failed to stat %s\n", UUIDPath.UTF8String);
        return -1;
    }
    
    uid_t curOwnerID = UUIDPathStat.st_uid;
    gid_t curGroupID = UUIDPathStat.st_gid;
    if (curOwnerID != 0 || curGroupID != 0) {
        if (chown(UUIDPath.UTF8String, 0, 0) != 0) {
            printf("Failed to chown 0:0 %s\n", UUIDPath.UTF8String);
            return -1;
        }
    }
    
    mode_t curPermissions = UUIDPathStat.st_mode & S_IRWXU;
    if (curPermissions != 0755) {
        if (chmod(UUIDPath.UTF8String, 0755) != 0) {
            printf("Failed to chmod 755 %s\n", UUIDPath.UTF8String);
            return -1;
        }
    }
    
    return 0;
}

char* getBootManifestHash(void) {
    io_registry_entry_t registryEntry = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/chosen");
    if (registryEntry == IO_OBJECT_NULL) {
        return NULL;
    }
    CFDataRef bootManifestHash = IORegistryEntryCreateCFProperty(registryEntry, CFSTR("boot-manifest-hash"), kCFAllocatorDefault, kNilOptions);
    if(!bootManifestHash) {
        return NULL;
    }
    
    IOObjectRelease(registryEntry);
    
    CFIndex length = CFDataGetLength(bootManifestHash) * 2 + 1;
    char *manifestHash = (char*)calloc(length, sizeof(char));
    
    int i = 0;
    for (i = 0; i<(int)CFDataGetLength(bootManifestHash); i++) {
        sprintf(manifestHash+i*2, "%02X", CFDataGetBytePtr(bootManifestHash)[i]);
    }
    manifestHash[i*2] = 0;
    
    CFRelease(bootManifestHash);
    
    return manifestHash;
}

void wipeSymlink(NSString *path) {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSError *error = nil;
    
    NSDictionary *attributes = [fileManager attributesOfItemAtPath:path error:&error];
    if (!error) {
        NSString *fileType = attributes[NSFileType];
        if ([fileType isEqualToString:NSFileTypeSymbolicLink]) {
            [fileManager removeItemAtPath:path error:&error];
            if (!error) {
                printf("Deleted symlink at %s\n", path.UTF8String);
            }
        } else {
            //[Logger print:[NSString stringWithFormat:@"Wanted to delete symlink at %@, but it is not a symlink", path]];
        }
    } else {
        //[Logger print:[NSString stringWithFormat:@"Wanted to delete symlink at %@, error occurred: %@, but we ignore it", path, error]];
    }
}

NSString* locateExistingFakeRoot(void) {
    NSString *bootManifestHash = [NSString stringWithUTF8String:getBootManifestHash()];
    if (!bootManifestHash) {
        return NULL;
    }
    
    NSString *ppPath = [NSString stringWithFormat:@"/private/preboot/%@", bootManifestHash];
    NSError *error = nil;
    NSArray<NSString *> *candidateURLs = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:ppPath error:&error];
    if (!error) {
        for (NSString *candidatePath in candidateURLs) {
            if ([candidatePath.lastPathComponent hasPrefix:@"jb-"]) {
                return [NSString stringWithFormat:@"%@/%@", ppPath, candidatePath];
            }
        }
    }
    return nil;
}

NSString* generateFakeRootPath(void) {
    NSString *letters = @"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    NSMutableString *result = [NSMutableString stringWithCapacity:6];
    
    for (NSUInteger i = 0; i < 6; i++) {
        NSUInteger randomIndex = arc4random_uniform((uint32_t)[letters length]);
        unichar randomCharacter = [letters characterAtIndex:randomIndex];
        [result appendFormat:@"%C", randomCharacter];
    }
    
    NSString *bootManifestHash = [NSString stringWithUTF8String:getBootManifestHash()];
    if (!bootManifestHash) {
        return NULL;
    }
    
    NSString *fakeRootPath = [NSString stringWithFormat:@"/private/preboot/%@/jb-%@", bootManifestHash, result];
    return fakeRootPath;
}

int untar(NSString *path, NSString *target_path) {
    NSString *tar_path = [NSString stringWithFormat:@"%@%@", NSBundle.mainBundle.bundlePath, @"/bootstrap/tar"];
    int ret = util_runCommand(tar_path.UTF8String, "--preserve-permissions", "-xvf", path.UTF8String, "-C", target_path.UTF8String, NULL);
    return ret;
}

void createSymbolicLink(NSString* path, NSString* pathContent) {
    NSArray<NSString *> *components = [path componentsSeparatedByString:@"/"];
    NSString *directoryPath = [[components subarrayWithRange:NSMakeRange(0, components.count - 1)] componentsJoinedByString:@"/"];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:directoryPath]) {
        NSError *error = nil;
        [fileManager createDirectoryAtPath:directoryPath withIntermediateDirectories:YES attributes:nil error:&error];
        if (error) {
            printf("Failed to create directory. Error: %s\n", error.description.UTF8String);
            return;
        }
    }
    
    NSError *error = nil;
    [fileManager createSymbolicLinkAtPath:path withDestinationPath:pathContent error:&error];
    if (error) {
        printf("Failed to create symbolic link. Error: %s\n", error.description.UTF8String);
        return;
    }
}

bool fileOrSymlinkExistsAtPath(NSString * path) {
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if ([fileManager fileExistsAtPath:path]) {
        return true;
    }
    
    NSError *error;
    NSDictionary *attributes = [fileManager attributesOfItemAtPath:path error:&error];
    if (attributes) {
        NSString *fileType = attributes[NSFileType];
        if ([fileType isEqualToString:NSFileTypeSymbolicLink]) {
            return true;
        }
    }
    
    return false;
}

int extractBootstrap(void) {
    NSString *jbPath = @"/var/jb";
    
    if(remountPrebootPartition(true) != 0) {
        printf("Failed to remount /private/preboot partition as writable");
        return -1;
    }
    UUIDPathPermissionFixup();
    
    // Remove existing /var/jb symlink if it exists (will be recreated later)
    wipeSymlink(jbPath);
    if([[NSFileManager defaultManager] fileExistsAtPath: jbPath]) {
        [[NSFileManager defaultManager] removeItemAtPath:jbPath error:nil];
    }
    
    // Ensure fake root directory inside /private/preboot exists
    NSString *fakeRootPath = locateExistingFakeRoot();
    printf("fakeRootPath: %s\n", fakeRootPath.UTF8String);
    if(fakeRootPath == nil) {
        fakeRootPath = generateFakeRootPath();
        [[NSFileManager defaultManager] createDirectoryAtPath:fakeRootPath withIntermediateDirectories:YES attributes:nil error:nil];
    }
    
    // Extract Procursus Bootstrap if neccessary
    bool bootstrapNeedsExtract = false;
    NSString *procursusPath = [NSString stringWithFormat:@"%@%@", fakeRootPath, @"/procursus"];
    NSString *palera1nPath = [NSString stringWithFormat:@"%@%@", fakeRootPath, @"/.installed_palera1n"];
    NSString *installedPath = [NSString stringWithFormat:@"%@%@", procursusPath, @"/.installed_kfund"];
    NSString *prereleasePath = [NSString stringWithFormat:@"%@%@", procursusPath, @"/.used_kfund_prelease"];
    
    if([[NSFileManager defaultManager] fileExistsAtPath:procursusPath]) {
        if(!([[NSFileManager defaultManager] fileExistsAtPath:palera1nPath]) && !([[NSFileManager defaultManager] fileExistsAtPath:installedPath])) {
            printf("Wiping existing bootstrap because installed file and palera1n file not found\n");
            [[NSFileManager defaultManager] removeItemAtPath:procursusPath error:nil];
        }
        if(![[NSFileManager defaultManager] fileExistsAtPath:prereleasePath]) {
            printf("Wiping existing bootstrap because pre release\n");
            [[NSFileManager defaultManager] removeItemAtPath:procursusPath error:nil];
        }
    }
    if(![[NSFileManager defaultManager] fileExistsAtPath:procursusPath]) {
        [[NSFileManager defaultManager] createDirectoryAtPath:procursusPath withIntermediateDirectories:YES attributes:nil error:nil];
        bootstrapNeedsExtract = true;
    }
    
    // Update basebin (should be done every rejailbreak)
    NSString *basebinTarPath = [NSString stringWithFormat:@"%@%@", NSBundle.mainBundle.bundlePath, @"/basebin.tar"];
    NSString *basebinPath = [NSString stringWithFormat:@"%@%@", procursusPath, @"/basebin"];
    if([[NSFileManager defaultManager] fileExistsAtPath:basebinPath]) {
        [[NSFileManager defaultManager] removeItemAtPath:basebinPath error:nil];
    }
    int untarRet = untar(basebinTarPath, procursusPath);
    if(untarRet != 0) {
        printf("Failed to untar Basebin, untarRet: %d\n", untarRet);
        return -1;
    }

    // Create /var/jb symlink
    createSymbolicLink(jbPath, procursusPath);
    
    // Extract Procursus if needed
    // XXX Not implemented
    
    // Update default sources
    // XXX Not implemented
    
    // Create basebin symlinks if they don't exist
    if(!fileOrSymlinkExistsAtPath(@"/var/jb/usr/bin/opainject")) {
        createSymbolicLink(@"/var/jb/usr/bin/opainject", [NSString stringWithFormat:@"%@%@", procursusPath, @"/basebin/opainject"]);
    }
    if(!fileOrSymlinkExistsAtPath(@"/var/jb/usr/bin/jbctl")) {
        createSymbolicLink(@"/var/jb/usr/bin/jbctl", [NSString stringWithFormat:@"%@%@", procursusPath, @"/basebin/jbctl"]);
    }
    if(!fileOrSymlinkExistsAtPath(@"/var/jb/usr/lib/libjailbreak.dylib")) {
        createSymbolicLink(@"/var/jb/usr/lib/libjailbreak.dylib", [NSString stringWithFormat:@"%@%@", procursusPath, @"/basebin/libjailbreak.dylib"]);
    }
    if(!fileOrSymlinkExistsAtPath(@"/var/jb/usr/lib/libfilecom.dylib")) {
        createSymbolicLink(@"/var/jb/usr/lib/libfilecom.dylib", [NSString stringWithFormat:@"%@%@", procursusPath, @"/basebin/libfilecom.dylib"]);
    }

    // Create preferences directory if it does not exist
    if(![[NSFileManager defaultManager] fileExistsAtPath:@"/var/jb/var/mobile/Library/Preferences"]) {
        NSDictionary *attributes = @{NSFilePosixPermissions: @(0755), NSFileOwnerAccountID: @(501), NSFileGroupOwnerAccountID: @(501)};
        [[NSFileManager defaultManager] createDirectoryAtPath:@"/var/jb/var/mobile/Library/Preferences" withIntermediateDirectories:YES attributes:attributes error:nil];
    }
    
    // Write boot info from cache to disk
    // XXX Not implemented
    
 
    return 0;
}
